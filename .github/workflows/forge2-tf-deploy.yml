# =============================================================================
# FORGE2-TF EC2 Docker Deployment
# =============================================================================
#
# This workflow deploys the FORGE2-TF application to EC2 using Docker containers
# Based on the ansible deployment configuration from cicd
#
# PREREQUISITES:
#   - AWS IAM role: ec2-role-analysistools-{tier}-role (with ECR, SSM permissions)
#   - GitHub Environment secrets: AWS_ACCOUNT_ID, EC2_INSTANCE_NAME
#   - ECR repository: analysistools/forge2-tf
#   - EC2 instance configured with docker-compose
#   - Config file at: /local/content/docker_apps/forge2-tf/config/config.json
#
# =============================================================================

name: Deploy FORGE2-TF to EC2
on:
  workflow_dispatch:
    inputs:
      tier:
        description: "Deployment Tier"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - qa
          - stage
          - prod

jobs:
  Deploy:
    runs-on: ubuntu-latest
    environment: ${{ inputs.tier }}
    env:
      APP: forge2-tf
      TZ: America/New_York
      AWS_REGION: us-east-1
      IMAGE_TIER: ${{ contains(fromJson('["dev","qa"]'), inputs.tier) && 'development' || 'release' }}
      APP_HOST_ROOT: /local/content/docker_apps/forge2-tf
      APP_HOST_CONFIG_FOLDER: /local/content/docker_apps/forge2-tf/config
      APP_HOST_LOGS_FOLDER: /local/content/docker_apps/forge2-tf/logs
      APP_HOST_DATA_FOLDER: /local/content/docker_apps/forge2-tf/data
      FRONTEND_PORT: 8101
      BACKEND_PORT: 8000
      DOCKER_COMPOSE_TEMPLATE_PATH: docker/docker-compose.deploy.yml

    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v6.0.1

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v5.1.1
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ec2-role-analysistools-${{ inputs.tier }}-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Set dynamic environment variables
        run: |
          TIMESTAMP=$(date +"%Y%m%d%H%M%S")
          REPO=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.$AWS_REGION.amazonaws.com/analysistools/${{ env.IMAGE_TIER }}/${{ env.APP }}
          echo "IMAGE_REPOSITORY=$REPO" >> $GITHUB_ENV
          echo "ECR_REGISTRY=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.$AWS_REGION.amazonaws.com" >> $GITHUB_ENV
          echo "FRONTEND_IMAGE=$REPO/frontend:${{ github.ref_name }}-$TIMESTAMP" >> $GITHUB_ENV
          echo "BACKEND_IMAGE=$REPO/backend:${{ github.ref_name }}-$TIMESTAMP" >> $GITHUB_ENV
          echo "FRONTEND_IMAGE_LATEST=$REPO/frontend:${{ github.ref_name }}-latest" >> $GITHUB_ENV
          echo "BACKEND_IMAGE_LATEST=$REPO/backend:${{ github.ref_name }}-latest" >> $GITHUB_ENV

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2.0.1

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3.12.0

      - name: Build and push backend image
        uses: docker/build-push-action@v6.18.0
        with:
          context: .
          file: docker/backend.dockerfile
          push: true
          tags: |
            ${{ env.BACKEND_IMAGE }}
            ${{ env.BACKEND_IMAGE_LATEST }}
          cache-from: type=registry,ref=${{ env.IMAGE_REPOSITORY }}/backend-cache
          cache-to: type=registry,ref=${{ env.IMAGE_REPOSITORY }}/backend-cache,image-manifest=true,oci-mediatypes=true,mode=max

      - name: Build and push frontend image
        uses: docker/build-push-action@v6.18.0
        with:
          context: .
          file: docker/frontend.dockerfile
          push: true
          tags: |
            ${{ env.FRONTEND_IMAGE }}
            ${{ env.FRONTEND_IMAGE_LATEST }}
          cache-from: type=registry,ref=${{ env.IMAGE_REPOSITORY }}/frontend-cache
          cache-to: type=registry,ref=${{ env.IMAGE_REPOSITORY }}/frontend-cache,image-manifest=true,oci-mediatypes=true,mode=max

      - name: Prepare docker-compose file
        run: |
          export APP_HOST_CONFIG_FOLDER="${{ env.APP_HOST_CONFIG_FOLDER }}"
          export APP_HOST_LOGS_FOLDER="${{ env.APP_HOST_LOGS_FOLDER }}"
          export APP_HOST_DATA_FOLDER="${{ env.APP_HOST_DATA_FOLDER }}"
          export BACKEND_IMAGE_LATEST="${{ env.BACKEND_IMAGE_LATEST }}"
          export FRONTEND_IMAGE_LATEST="${{ env.FRONTEND_IMAGE_LATEST }}"
          export BACKEND_PORT="${{ env.BACKEND_PORT }}"
          export FRONTEND_PORT="${{ env.FRONTEND_PORT }}"

          envsubst < $DOCKER_COMPOSE_TEMPLATE_PATH > docker-compose-rendered.yml

          echo "Rendered docker-compose.yml:"
          cat docker-compose-rendered.yml

          # Base64 encode for safe transfer
          COMPOSE_BASE64=$(base64 -w 0 docker-compose-rendered.yml 2>/dev/null || base64 docker-compose-rendered.yml)
          echo "compose_base64=$COMPOSE_BASE64" >> $GITHUB_OUTPUT
        id: compose

      - name: Get EC2 instance ID
        id: get-instance
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=${{ secrets.EC2_INSTANCE_NAME }}" \
                      "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)

          if [ "$INSTANCE_ID" == "None" ] || [ -z "$INSTANCE_ID" ]; then
            echo "Error: Could not find running EC2 instance with name ${{ secrets.EC2_INSTANCE_NAME }}"
            exit 1
          fi

          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT

      - name: Deploy to EC2 via SSM
        run: |
          # Create deployment commands as JSON
          cat > commands.json << 'EOF'
          {
            "Parameters": {
              "commands": [
                "set -e",
                "echo '=== Starting FORGE2-TF deployment ==='",
                "cd ${{ env.APP_HOST_ROOT }}",
                "echo '=== Logging in to ECR ==='",
                "aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}",
                "echo '=== Creating required directories ==='",
                "mkdir -p ${{ env.APP_HOST_CONFIG_FOLDER }}",
                "mkdir -p ${{ env.APP_HOST_LOGS_FOLDER }}",
                "mkdir -p ${{ env.APP_HOST_LOGS_FOLDER }}/apache",
                "mkdir -p ${{ env.APP_HOST_DATA_FOLDER }}",
                "mkdir -p ${{ env.APP_HOST_DATA_FOLDER }}/tmp",
                "mkdir -p ${{ env.APP_HOST_DATA_FOLDER }}/motif-logos",
                "echo '=== Creating docker-compose.yml ==='",
                "echo '${{ steps.compose.outputs.compose_base64 }}' | base64 -d > docker-compose.yml",
                "echo 'Generated docker-compose.yml:'; cat docker-compose.yml",
                "echo '=== Pulling latest images ==='",
                "docker compose pull --quiet",
                "echo '=== Stopping ${{ env.APP }} containers ==='",
                "docker ps --filter name=${{ env.APP }} -q | xargs -r docker stop || echo 'No ${{ env.APP }} containers running'",
                "echo '=== Finding and stopping containers on port ${{ env.FRONTEND_PORT }} ==='",
                "CONTAINER_${{ env.FRONTEND_PORT }}=$(docker ps --format '{{.ID}} {{.Ports}}' | grep '0.0.0.0:${{ env.FRONTEND_PORT }}' | awk '{print $1}')",
                "if [ -n \"$CONTAINER_${{ env.FRONTEND_PORT }}\" ]; then echo \"Stopping container using port ${{ env.FRONTEND_PORT }}: $CONTAINER_${{ env.FRONTEND_PORT }}\"; docker stop $CONTAINER_${{ env.FRONTEND_PORT }}; fi",
                "echo '=== Running compose down ==='",
                "docker compose down --remove-orphans || true",
                "echo '=== Removing ${{ env.APP }} containers ==='",
                "docker ps -a --filter name=${{ env.APP }} -q | xargs -r docker rm -f || echo 'No ${{ env.APP }} containers to remove'",
                "echo '=== Waiting for port release ==='",
                "sleep 3",
                "echo '=== Current containers ==='",
                "docker ps -a",
                "echo '=== Starting new containers ==='",
                "docker compose up -d",
                "echo '=== Verifying containers are running ==='",
                "sleep 5",
                "docker ps --filter name=${{ env.APP }}",
                "echo '=== FORGE2-TF deployment completed ==='"
              ]
            }
          }
          EOF

          # Send command to EC2 and execute
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ steps.get-instance.outputs.instance_id }}" \
            --document-name "AWS-RunShellScript" \
            --cli-input-json file://commands.json \
            --query "Command.CommandId" \
            --output text)

          echo "SSM Command ID: $COMMAND_ID"

          # Wait for the command to finish
          echo "Waiting for deployment to complete..."
          for i in {1..60}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ steps.get-instance.outputs.instance_id }}" \
              --query "Status" \
              --output text)
            
            echo "Status: $STATUS (attempt $i/60)"
            
            if [[ "$STATUS" == "Success" ]]; then
              echo "✅ Deployment successful!"
              break
            elif [[ "$STATUS" =~ ^(Failed|Cancelled|TimedOut)$ ]]; then
              echo "❌ Deployment failed with status: $STATUS"

              echo ""
              echo "=== Deployment Output ==="
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ steps.get-instance.outputs.instance_id }}" \
                --query "StandardOutputContent" \
                --output text
              
              echo ""
              echo "=== Deployment Errors ==="
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ steps.get-instance.outputs.instance_id }}" \
                --query "StandardErrorContent" \
                --output text
              
              exit 1
            fi
            
            sleep 5
          done

          echo ""
          echo "=== Deployment Output ==="
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ steps.get-instance.outputs.instance_id }}" \
            --query "StandardOutputContent" \
            --output text
